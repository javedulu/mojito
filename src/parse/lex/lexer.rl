#include <stddef.h>
#include <string>
#include <utility>
#include "lexer.h"
#include "lexeme.h"

// NOTE : if the lemon-parser is properly done then all the #define in lemon-parser.h should be equal
//        to total no of tokens
//        lemon-parser.h is generated by lemon based on whats used in parser , so if all the cases are
//              considered then there should be no token not # defined failsafe
%% machine umodLexer;
%% write data;

// no idea about the origins of this value, ask Flori ;)
int EVIL=0x666;

using namespace umod::lex;

Lexer::Lexer(const char *source, unsigned int length)
    : m_source(source)
    , m_source_end(source + length)
    , m_source_eof(m_source_end)
    , m_ts(nullptr), m_te(nullptr)
    , m_current_state(EVIL), m_act(0)
    , m_position(std::make_pair(1, 1))
{

}

Lexer::Lexer(const std::string &source): Lexer(source.c_str(), source.length())
{

}

Lexer::~Lexer()
{

}

Lexeme *Lexer::consume(void)
{
    %%{
        ident               = [a-zA-Z$_][a-zA-Z0-9$_]*;
        
        fract_const = [+\-]? digit* '.' digit+ | digit+ '.';
        exponent = [eE] [+\-]? digit+;
        
        float               = ( fract_const exponent? | digit+ exponent );
        number              = [+\-]?[0-9]+;
        
        string              = ('"'([^"]|'\\' any)*'"'|'\''([^']|'\\' any)*'\'');

        spaces              = (' '|'\t')+;
        newline             = ('\n');

        linecomment         =  '//'[^\n]*;
        blockcomment        = '/*' ( any* - (any* '*/' any* ) ) '*/';
        comment             = linecomment | blockcomment;

        main := |*
            'algorithm'            => { type = Lexeme::Type::Algorithm; fbreak; };
            'discrete'             => { type = Lexeme::Type::Discrete; fbreak; };
            'false'                => { type = Lexeme::Type::False; fbreak; };
            'loop'                 => { type = Lexeme::Type::Loop; fbreak; };
            'pure'                 => { type = Lexeme::Type::Pure; fbreak; };
            'and'                  => { type = Lexeme::Type::And; fbreak; };
            'each'                 => { type = Lexeme::Type::Each; fbreak; };
            'final'                => { type = Lexeme::Type::Final; fbreak; };
            'model'                => { type = Lexeme::Type::Model; fbreak; };
            'record'               => { type = Lexeme::Type::Record; fbreak; };
            'annotation'           => { type = Lexeme::Type::Annotation; fbreak; };
            'else'                 => { type = Lexeme::Type::Else; fbreak; };
            'flow'                 => { type = Lexeme::Type::Flow; fbreak; };
            'not'                  => { type = Lexeme::Type::Not; fbreak; };
            'redeclare'            => { type = Lexeme::Type::Redeclare; fbreak; };
            'assert'               => { type = Lexeme::Type::Assert; fbreak; };
            'elseif'               => { type = Lexeme::Type::Elseif; fbreak; };
            'for'                  => { type = Lexeme::Type::For; fbreak; };
            'operator'             => { type = Lexeme::Type::Operator; fbreak; };
            'replaceable'          => { type = Lexeme::Type::Replaceable; fbreak; };
            'block'                => { type = Lexeme::Type::Block; fbreak; };
            'elsewhen'             => { type = Lexeme::Type::Elsewhen; fbreak; };
            'function'             => { type = Lexeme::Type::Function; fbreak; };
            'or'                   => { type = Lexeme::Type::Or; fbreak; };
            'return'               => { type = Lexeme::Type::Return; fbreak; };
            'break'                => { type = Lexeme::Type::Break; fbreak; };
            'encapsulated'         => { type = Lexeme::Type::Encapsulated; fbreak; };
            'if'                   => { type = Lexeme::Type::If; fbreak; };
            'outer'                => { type = Lexeme::Type::Outer; fbreak; };
            'stream'               => { type = Lexeme::Type::Stream; fbreak; };
            'class'                => { type = Lexeme::Type::Class; fbreak; };
            'end'                  => { type = Lexeme::Type::End; fbreak; };
            'import'               => { type = Lexeme::Type::Import; fbreak; };
            'output'               => { type = Lexeme::Type::Output; fbreak; };
            'then'                 => { type = Lexeme::Type::Then; fbreak; };
            'connect'              => { type = Lexeme::Type::Connect; fbreak; };
            'enumeration'          => { type = Lexeme::Type::Enumeration; fbreak; };
            'impure'               => { type = Lexeme::Type::Impure; fbreak; };
            'package'              => { type = Lexeme::Type::Package; fbreak; };
            'true'                 => { type = Lexeme::Type::True; fbreak; };
            'connector'            => { type = Lexeme::Type::Connector; fbreak; };
            'equation'             => { type = Lexeme::Type::Equation; fbreak; };
            'in'                   => { type = Lexeme::Type::In; fbreak; };
            'parameter'            => { type = Lexeme::Type::Parameter; fbreak; };
            'type'                 => { type = Lexeme::Type::Type; fbreak; };
            'constant'             => { type = Lexeme::Type::Constant; fbreak; };
            'expandable'           => { type = Lexeme::Type::Expandable; fbreak; };
            'initial'              => { type = Lexeme::Type::Initial; fbreak; };
            'partial'              => { type = Lexeme::Type::Partial; fbreak; };
            'when'                 => { type = Lexeme::Type::When; fbreak; };
            'constrainedby'        => { type = Lexeme::Type::Constrainedby; fbreak; };
            'extends'              => { type = Lexeme::Type::Extends; fbreak; };
            'inner'                => { type = Lexeme::Type::Inner; fbreak; };
            'protected'            => { type = Lexeme::Type::Protected; fbreak; };
            'while'                => { type = Lexeme::Type::While; fbreak; };
            'der'                  => { type = Lexeme::Type::Der; fbreak; };
            'external'             => { type = Lexeme::Type::External; fbreak; };
            'input'                => { type = Lexeme::Type::Input; fbreak; };
            'public'               => { type = Lexeme::Type::Public; fbreak; };
            'within'               => { type = Lexeme::Type::Within; fbreak; };

            '+'             => { type = Lexeme::Type::Plus; fbreak; };
            '-'             => { type = Lexeme::Type::Minus; fbreak; };
            '*'             => { type = Lexeme::Type::Mul; fbreak; };
            '/'             => { type = Lexeme::Type::Div; fbreak; };
            '^'             => { type = Lexeme::Type::Exponent; fbreak; };

            '='             => { type = Lexeme::Type::Assign; fbreak; };
            '+='            => { type = Lexeme::Type::PlusAssign; fbreak; };
            '-='            => { type = Lexeme::Type::MinusAssign; fbreak; };
            '*='            => { type = Lexeme::Type::MulAssign; fbreak; };
            '/='            => { type = Lexeme::Type::DivAssign; fbreak; };

            '>'             => { type = Lexeme::Type::Greater; fbreak; };
            '>='            => { type = Lexeme::Type::GreaterOrEqual; fbreak; };
            '<'             => { type = Lexeme::Type::Lesser; fbreak; };
            '<='            => { type = Lexeme::Type::LesserOrEqual; fbreak; };
            '=='            => { type = Lexeme::Type::Equal; fbreak; };
            '<>'            => { type = Lexeme::Type::NotEqual; fbreak; };

            '!'             => { type = Lexeme::Type::Negate; fbreak; };
            '~'             => { type = Lexeme::Type::Inv; fbreak; };
            '++'            => { type = Lexeme::Type::Incrementation; fbreak; };
            '--'            => { type = Lexeme::Type::Decrementation; fbreak; };

            '('             => { type = Lexeme::Type::LParen; fbreak; };
            ')'             => { type = Lexeme::Type::RParen; fbreak; };
            '['             => { type = Lexeme::Type::LBracket; fbreak; };
            ']'             => { type = Lexeme::Type::RBracket; fbreak; };
            '{'             => { type = Lexeme::Type::LBrace; fbreak; };
            '}'             => { type = Lexeme::Type::RBrace; fbreak; };

            '?'             => { type = Lexeme::Type::QuestionMark; fbreak; };
            '.'             => { type = Lexeme::Type::Dot; fbreak; };

            ';'             => { type = Lexeme::Type::Semicolon; fbreak; };
            ':'             => { type = Lexeme::Type::Colon; fbreak; };
            ','             => { type = Lexeme::Type::Comma; fbreak; };

            ident           => { type = Lexeme::Type::Ident; fbreak; };
            float           => { type = Lexeme::Type::Float; fbreak; };
            number          => { type = Lexeme::Type::Number; fbreak; };
            string          => { type = Lexeme::Type::String; fbreak; };

            spaces          => { type = Lexeme::Type::Spaces; fbreak; };
            newline         => { type = Lexeme::Type::Newline; fbreak; };

            comment     => { type = Lexeme::Type::Comment; fbreak; };
            any             => { fbreak; };
        *|;
    }%%

    Lexeme::Type type;

    if (m_source == m_source_end)
    {
        m_ts = m_te = m_source;
        type = Lexeme::Type::Eof;
    }
    else
    {
        %% variable cs  m_current_state;
        %% variable p   m_source;
        %% variable pe  m_source_end;
        %% variable eof m_source_eof;
        %% variable ts  m_ts;
        %% variable te  m_te;
        %% variable act m_act;

        %% write init;
        %% write exec;
    }

    unsigned int size = m_te - m_ts;
    Lexeme::pos_t position = m_position;

    if (type == Lexeme::Type::Newline)
    {
        m_position.first += 1;
        m_position.second = size;
    }
    else
    {
        m_position.second += size;
    }

    return new Lexeme(type, std::string(m_ts, size), position);
}

