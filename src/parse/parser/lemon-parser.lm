%token_prefix           UMOD_LEXEME_TYPE_
%token_type             {lex::Lexeme *}
%extra_argument         {parser::Parser *parser}
%name                   umodParse
%include {
    #include <cassert>
    #include <cstdio>
    #include <vector>
    #include <string>
    #include <iostream>
    #include "lexeme.h"
    #include "parser.h"
    using namespace umod;
}
%syntax_error {
    int n = sizeof(yyTokenName)/ sizeof(*yyTokenName);
    for (int i = 0; i< n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            parser->errors().push_back(yyTokenName[i]);
        }
    }
    parser->error(true);
}

%left PLUS MINUS MUL DIV.

%left ASSIGN PLUSASSIGN MINUSASSIGN MULASSIGN DIVASSIGN.

%left GREATER GREATEROREQUAL LESSER LESSEROREQUAL EQUAL NOTEQUAL.

%left NOT INV INCREMENTATION DECREMENTATION.

%left LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE.


%left SEMICOLON COLON COMMA.

%left IDENT NUMBER FLOAT STRING COMMENT.

%left QUESTIONMARK DOT.

%left ALGORITHM  AND   ANNOTATION ASSERT BLOCK BREAK CLASS.
%left CONNECT  CONNECTOR  CONSTANT   CONSTRAINEDBY   DER.
%left DISCRETE  EACH  ELSE  ELSEIF ELSEWHEN   ENCAPSULATED.    
%left END   ENUMERATION EQUATION   EXPANDABLE EXPONENT   EXTENDS.
%left EXTERNAL  FALSE FINAL FLOW  FOR   FUNCTION   IF    IMPORT.
%left IMPURE IN    INITIAL    INNER INPUT LOOP  MODEL NEGATE OPERATOR.
%left OR    OUTER OUTPUT PACKAGE    PARAMETER  PARTIAL    PROTECTED.
%left PUBLIC PURE  RECORD REDECLARE  REPLACEABLE RETURN.
%left STREAM THEN  TRUE  TYPE  WHEN  WHILE WITHIN.

stored_definition ::= WITHIN name(A) SEMICOLON. { std::cout<<A<<std::endl;}
name(A) ::= name DOT IDENT(B). { A=B;}
name ::= IDENT(B)