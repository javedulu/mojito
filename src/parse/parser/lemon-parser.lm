%token_prefix           UMOD_LEXEME_TYPE_
%token_type             {lex::Lexeme *}
%extra_argument         {parser::Parser *parser}
%name                   umodParse
%include {
    #include <cassert>
    #include <cstdio>
    #include <vector>
    #include <string>
    #include <iostream>
    #include "lexeme.h"
    #include "parser.h"
    using namespace umod;
}

%parse_accept {
    std::cout<<"Parsing Complete !! \n";
}

%syntax_error {
    int n = sizeof(yyTokenName)/ sizeof(*yyTokenName);
    for (int i = 0; i< n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            parser->errors().push_back(yyTokenName[i]);
        }
    }
    parser->error(true);
}

%left ASSING.
%left EQUAL.
%left THEN.
%left ELSE.

%left COLON.

%left NOT.
%left AND OR.

%left LOWER GREATER LOWEREQ GREATEREQ COMPEQ COMPNE.

%left PLUS DOTPLUS MINUS DOTMINUS.

%left UMINUS UPLUS.

%left SLASH DOTSLASH STAR DOTSTAR.

%right CARET.
%right DOTCARET.

%left FC.
%left PARENS.

%left SEMICOLON COMMA.

%left OBRACE CBRACE OBRACKET CBRACKET OPAREN CPAREN.

%left IDENT STRING.


/*
%left PLUS MINUS MUL DIV.

%left ASSIGN PLUSASSIGN MINUSASSIGN MULASSIGN DIVASSIGN.

%left GREATER GREATEROREQUAL LESSER LESSEROREQUAL EQUAL NOTEQUAL.

%left NOT INV INCREMENTATION DECREMENTATION.

%left LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE.


%left SEMICOLON COLON COMMA.

%left IDENT NUMBER FLOAT STRING COMMENT.

%left QUESTIONMARK DOT.

%left ALGORITHM  AND   ANNOTATION ASSERT BLOCK BREAK CLASS.
%left CONNECT  CONNECTOR  CONSTANT   CONSTRAINEDBY   DER.
%left DISCRETE  EACH  ELSE  ELSEIF ELSEWHEN   ENCAPSULATED.
%left END   ENUMERATION EQUATION   EXPANDABLE EXPONENT   EXTENDS.
%left EXTERNAL  FALSE FINAL FLOW  FOR   FUNCTION   IF    IMPORT.
%left IMPURE IN    INITIAL    INNER INPUT LOOP  MODEL NEGATE OPERATOR.
%left OR    OUTER OUTPUT PACKAGE    PARAMETER  PARTIAL    PROTECTED.
%left PUBLIC PURE  RECORD REDECLARE  REPLACEABLE RETURN.
%left STREAM THEN  TRUE  TYPE  WHEN  WHILE WITHIN.
 */

program ::= stored_definition.{}

stored_definition ::= opt_within_name class_definition_list .{}

opt_within_name ::= WITHIN opt_name SEMICOLON. {}
opt_within_name ::= . {}

opt_name ::= name.{}
opt_name ::= .{}

name ::= name DOT IDENT. {}
name ::= DOT IDENT.{}
name ::= IDENT. {}


class_definition_list ::= .{}
class_definition_list ::= class_definition_list class_definition_aux. {}

class_definition_aux ::= opt_final class_definition SEMICOLON.{}

class_definition ::=  opt_encapsulated class_prefix class_specifier.{}

opt_encapsulated ::= ENCAPSULATED. { }
opt_encapsulated ::= .{}

class_prefix ::= opt_partial class_prefixes.{}

opt_expandable ::= EXPANDABLE. {}
opt_expandable ::= . {}

opt_pure_impure_operator ::= PURE opt_operator. {}
opt_pure_impure_operator ::= IMPURE opt_operator. {}
opt_pure_impure_operator ::= . {}

opt_final ::= FINAL. {}
opt_final ::= . {}

class_prefixes ::= CLASS. {  }
class_prefixes ::= MODEL. {  }
class_prefixes ::= opt_operator RECORD. {  }
class_prefixes ::= BLOCK. {  }
class_prefixes ::= opt_expandable CONNECTOR. {  }
class_prefixes ::= TYPE. {  }
class_prefixes ::= PACKAGE. {  }
class_prefixes ::= opt_pure_impure_operator FUNCTION. {  }
class_prefixes ::= OPERATOR. {  }


opt_operator ::= OPERATOR. {}
opt_operator ::= . {}


opt_partial ::= PARTIAL. {}
opt_partial ::= . {}


class_specifier ::= IDENT string_comment composition END IDENT. { }
class_specifier ::= IDENT EQUAL base_prefix name opt_array_subscripts opt_class_modification comment. { }
class_specifier ::= IDENT EQUAL ENUMERATION OPAREN enumeration_args CPAREN comment. {}
class_specifier ::= IDENT EQUAL DER OPAREN name COMA IDENT more_ids CPAREN comment. {}
class_specifier ::= EXTENDS IDENT opt_class_modification string_comment composition END IDENT.{}

more_ids ::= more_ids COMA IDENT.{}
more_ids ::= .{}

composition ::= composition_aux_1 opt_external_composition opt_annotation_composition. {}

opt_external_composition ::= EXTERNAL opt_language_specification opt_external_function_call opt_annotation SEMICOLON.{}
opt_external_composition ::= EXTERNAL opt_language_specification component_reference EQUAL opt_external_function_call opt_annotation SEMICOLON. {}
opt_external_composition ::= .{}

opt_language_specification ::= STRING. {}
opt_language_specification ::= .{}

opt_external_function_call ::= IDENT OPAREN CPAREN.{}
opt_external_function_call ::= IDENT OPAREN expression_list CPAREN.{}
opt_external_function_call ::= .{}

opt_annotation_composition ::= annotation SEMICOLON.{}
opt_annotation_composition ::= .{}

composition_aux_1 ::= element SEMICOLON element_list.{}
composition_aux_1 ::= element SEMICOLON element_list composition_element composition_list.{}
composition_aux_1 ::= composition_element composition_list.{}
composition_aux_1 ::= .{}

string_comment ::= .{}
string_comment ::= STRING. {}
string_comment ::= STRING PLUS string_comment_no_empty. {}

string_comment_no_empty ::= STRING PLUS string_comment_no_empty.{}
string_comment_no_empty ::= STRING.{}

element ::= import_clause.{}
element ::= extends_clause .{}
element ::= opt_redeclare opt_final opt_inner opt_outer element_option opt_constraining_clause.{}

import_clause ::= IMPORT opt_import comment.{}

opt_import ::= IDENT EQUAL name.{}
opt_import ::= name opt_import_spec .{}

opt_import_spec ::=. {}
opt_import_spec ::=  DOTSTAR. {}
opt_import_spec ::=  DOT OBRACE import_list CBRACE.{}

import_list ::= IDENT.{}
import_list ::= IDENT COMA import_list.{}

comment ::= string_comment opt_annotation. {}

element_list ::= .{}
element_list ::= element SEMICOLON element_list .{}

extends_clause ::= EXTENDS name opt_class_modification opt_annotation. {}

opt_redeclare ::= .{}
opt_redeclare ::= REDECLARE .{}

opt_inner ::= .{}
opt_inner ::= INNER. {}

opt_outer ::= .{}
opt_outer ::= OUTER.{}

opt_constraining_clause ::=.{}
opt_constraining_clause ::= constraining_clause comment. {}

constraining_clause ::= CONSTRAINEDBY name opt_class_modification.{}

element_option ::= element_option_1.{}
element_option ::= REPLACABLE element_option_1.{}

element_option_1 ::= class_definition .{}
element_option_1 ::= component_clause .{}

component_clause ::= type_prefix type_specifier opt_array_subscripts component_list .{}

type_prefix ::= opt_input_output.{}
type_prefix ::= opt_disc_param_const.{}
type_prefix ::= opt_disc_param_const opt_input_output.{}
type_prefix ::= opt_flow_stream.{}
type_prefix ::= opt_flow_stream opt_disc_param_const .{}
type_prefix ::= opt_flow_stream opt_disc_param_const opt_input_output.{}
type_prefix ::= .{}

opt_flow_stream ::= FLOW.{}
opt_flow_stream ::= STREAM.{}

opt_disc_param_const ::= DISCRETE.{}
opt_disc_param_const ::= PARAMETER.{}
opt_disc_param_const ::= CONSTANT.{}

opt_input_output ::= INPUT.{}
opt_input_output ::= OUTPUT.{}

type_specifier ::= name. {}

opt_array_subscripts ::= array_subscripts .{}
opt_array_subscripts ::= .{}

component_list ::= component_declaration. {}
component_list ::= component_list COMA component_declaration. {}

component_declaration ::= declaration opt_condition_attribute comment. {}

declaration ::= IDENT opt_array_subscripts opt_modification.{}

opt_condition_attribute ::= IF expression .{}
opt_condition_attribute ::= .{}

composition_list ::= composition_list composition_element.{}
composition_list ::= .{}

composition_element ::= PUBLIC element_list. {}
composition_element ::= PROTECTED element_list. {}
composition_element ::= eq_alg_section_init. {}

opt_modification ::= .{}
opt_modification ::= modification .{}

modification ::= class_modification opt_equal_exp .{}
modification ::= EQUAL expression. {}
modification ::= ASSING expression. {}

class_modification ::= OPAREN opt_argument_list CPAREN. {}

opt_argument_list ::= argument_list.{}
opt_argument_list ::= .{}

argument_list ::= argument_list COMA argument.{}
argument_list ::= argument.{}

argument ::= element_modification_replacable.{}
argument ::= element_redeclaration.{}

opt_each ::= .{}
opt_each ::= EACH.{}

element_modification_replacable ::= opt_each opt_final element_modification. {}
element_modification_replacable ::= opt_each opt_final element_replacable. {}

element_modification ::= name opt_modification string_comment .{}

element_replacable ::= REPLACEABLE short_class_definition opt_constraining_clause. {}
element_replacable ::= REPLACEABLE component_clause1 opt_constraining_clause. {}

opt_equal_exp ::= .{}
opt_equal_exp ::= EQUAL expression.{}

element_redeclaration ::= REDECLARE opt_each opt_final element_redeclaration_1 .{}

element_redeclaration_1 ::= element_redeclaration_2. {}
element_redeclaration_1 ::= element_replacable. {}

element_redeclaration_2 ::= short_class_definition.{}
element_redeclaration_2 ::= component_clause1.{}

short_class_definition ::= class_prefixes IDENT EQUAL short_class_definition_exp .{}

short_class_definition_exp ::= base_prefix name opt_array_subscripts opt_class_modification comment .{}
short_class_definition_exp ::= ENUMERATION OPAREN enumeration_args CPAREN comment. {}

enumeration_args ::= SEMICOLON.{}
enumeration_args ::= enum_list .{}

enum_list ::= enumeration_literal .{}
enum_list ::= enum_list COMA enumeration_literal .{}

enumeration_literal ::= IDENT comment .{}

component_clause1 ::= type_prefix type_specifier component_declaration1. {}

component_declaration1 ::= declaration comment. {}

opt_class_modification ::= class_modification.{}
opt_class_modification ::= .{}

base_prefix ::= type_prefix.{}

subscript_list ::= subscript .{}
subscript_list ::= subscript_list COMA subscript.{}

subscript ::= COLON.{}
subscript ::= expression.{}

array_subscripts ::= OBRACKET subscript_list CBRACKET .{}

opt_annotation ::= annotation.{}
opt_annotation ::= .{}

annotation ::= ANNOTATION class_modification .{}

eq_alg_section_init ::= INITIALEQ equation_list .{}
eq_alg_section_init ::= EQUATION equation_list .{}
eq_alg_section_init ::= INITIALALG statement_list.{}
eq_alg_section_init ::= ALGORITHM statement_list.{}

equation_list ::= equation_list equation SEMICOLON.{}
equation_list ::= .{}

equation ::= simple_expression EQUAL expression comment. {}
equation ::= if_equation comment .{}
equation ::= for_equation comment.{}
equation ::= connect_clause comment .{}
equation ::= when_equation comment.{}
equation ::= primary.{}

for_indices ::= for_index opt_more_indexes.{}

opt_more_indexes ::= opt_more_indexes COMA for_index .{}
opt_more_indexes ::= .{}

for_index ::= IDENT opt_in .{}

opt_in ::= IN expression.{}
opt_in ::= .{}

for_equation ::= FOR for_indices LOOP equation_list END FOR .{}

when_equation ::= WHEN expression THEN equation_list opt_else_when END WHEN .{}

opt_else_when ::= opt_else_when ELSEWHEN expression THEN equation_list.{}
opt_else_when ::= .{}

if_equation ::= IF expression THEN equation_list opt_elseif_eq opt_else_eq END IF.{}

opt_elseif_eq ::= opt_elseif_eq ELSEIF expression THEN equation_list .{}

opt_else_eq ::= ELSE equation_list.{}
opt_else_eq ::= .{}

connect_clause ::= CONNECT OPAREN component_reference COMA component_reference CPAREN.{}

statement_list ::= statement_list statement SEMICOLON.{}
statement_list ::= .{}

statement ::= component_reference opt_assing comment .{}
statement ::= OPAREN output_expression_list CPAREN ASSING component_reference function_call_args.{}
statement ::= while_statement comment.{}
statement ::= when_statement .{}
statement ::= for_statement comment.{}
statement ::= if_statement comment.{}
statement ::= BREAK comment.{}
statement ::= RETURN comment.{}

while_statement ::= WHILE expression LOOP statement_list END WHILE .{}

when_statement ::= WHEN expression THEN statement_list opt_else_when_list END WHEN comment .{}

opt_else_when_list ::= opt_else_when_list ELSEWHEN expression THEN statement_list. {}
opt_else_when_list ::= .{}

for_statement ::= FOR for_indices LOOP statement_list END FOR .{}

if_statement ::= IF expression THEN statement_list opt_esleif_st opt_else_st END IF .{}

opt_esleif_st ::= opt_esleif_st ELSEIF expression THEN statement_list.{}
opt_esleif_st ::= .{}

opt_else_st ::= .{}
opt_else_st ::= ELSE statement_list .{}

output_expression_list ::= expression output_expression_list_more .{}
output_expression_list ::= .{}

output_expression_list_more ::= COMA opt_expression output_expression_list_more .{}
output_expression_list_more ::= .{}

opt_named_arguments ::= named_arguments.{}
opt_named_arguments ::= .{}

named_arguments ::= named_argument opt_more_args .{}

named_argument  ::=  IDENT EQUAL function_argument .{}

opt_more_args ::= COMA named_arguments.{}
opt_more_args ::= .{}

opt_assing ::= ASSING expression. {}
opt_assing ::= function_call_args . {}

function_argument ::= FUNCTION name OPAREN opt_named_arguments CPAREN .{}
function_argument ::= expression.{}

function_call_args ::= OPAREN opt_function_args CPAREN .{}

opt_function_args ::= function_arguments .{}
opt_function_args ::= .{}

function_arguments ::= function_argument opt_function_arguments .{}
function_arguments ::= named_argument opt_function_arguments.{}

opt_function_arguments ::= COMA function_arguments .{}
opt_function_arguments ::= COMA for_indices.{}
opt_function_arguments ::= .{}

/****** Expressions *****/
expression ::= primary .{}
expression ::= OPAREN output_expression_list CPAREN PARENS .{}
expression ::= MINUS expression UMINUS .{}
expression ::= PLUS expression UPLUS .{}
expression ::= NOT expression. {}
expression ::= expression COLON expression.{}
expression ::= expression LOWER expression.{}
expression ::= expression LOWEREQ expression.{}
expression ::= expression GREATER expression.{}
expression ::= expression GREATEREQ expression.{}
expression ::= expression COMPNE expression.{}
expression ::= expression COMPEQ expression.{}
expression ::= expression SLASH expression.{}
expression ::= expression DOTSLASH expression.{}
expression ::= expression STAR expression.{}
expression ::= expression DOTSTAR expression.{}
expression ::= expression PLUS expression.{}
expression ::= expression MINUS expression.{}
expression ::= expression DOTPLUS expression.{}
expression ::= expression DOTMINUS expression.{}
expression ::= expression CARET expression.{}
expression ::= expression DOTCARET expression.{}
expression ::= expression AND expression.{}
expression ::= expression OR expression.{}
expression ::= IF expression THEN expression opt_elseif_exp ELSE expression .{}

opt_expression ::= expression .{}
opt_expression ::= .{}

opt_elseif_exp ::= opt_elseif_exp ELSEIF expression THEN expression.{}
opt_elseif_exp ::= .{}

primary ::= INT .{}
primary ::= FLOAT .{}
primary ::= STRING .{}
primary ::= FALSE .{}
primary ::= TRUE.{}
primary ::= DER function_call_args.{}
primary ::= INITIAL function_call_args.{}
primary ::= opt_comp_call.{}
primary ::= OBRACKET expression_list primary_exp_list CBRACKET.{}
primary ::= OBRACE function_arguments CBRACE .{}
primary ::= ENDSUB.{}

primary_exp_list ::= primary_exp_list SEMICOLON expression_list .{}
primary_exp_list ::= .{}

component_reference ::= IDENT opt_array_subscripts component_reference_list .{}
component_reference ::= DOT IDENT opt_array_subscripts component_reference_list .{}

expression_list_more ::= COMA expression_list .{}
expression_list_more ::= .{}

expression_list ::= expression expression_list_more .{}

component_reference_list ::= component_reference_list DOT IDENT opt_array_subscripts.{}
component_reference_list ::= .{}

simple_expression ::= primary .{}
simple_expression ::= OPAREN output_expression_list CPAREN PARENS .{}
simple_expression ::= MINUS expression UMINUS .{}
simple_expression ::= PLUS expression UPLUS.{}
simple_expression ::= NOT expression .{}
simple_expression ::= simple_expression COLON expression .{}
simple_expression ::= simple_expression LOWER expression .{}
simple_expression ::= simple_expression LOWEREQ expression .{}
simple_expression ::= simple_expression GREATER expression .{}
simple_expression ::= simple_expression GREATEREQ expression .{}
simple_expression ::= simple_expression COMPNE expression .{}
simple_expression ::= simple_expression COMPEQ expression .{}
simple_expression ::= simple_expression SLASH expression .{}
simple_expression ::= simple_expression DOTSLASH expression .{}
simple_expression ::= simple_expression STAR expression .{}
simple_expression ::= simple_expression DOTSTAR expression .{}
simple_expression ::= simple_expression PLUS expression .{}
simple_expression ::= simple_expression MINUS expression .{}
simple_expression ::= simple_expression DOTPLUS expression .{}
simple_expression ::= simple_expression DOTMINUS expression .{}
simple_expression ::= simple_expression CARET expression .{}
simple_expression ::= simple_expression DOTCARET expression .{}
simple_expression ::= simple_expression AND expression .{}
simple_expression ::= simple_expression OR expression .{}

more_cr ::= more_cr DOT IDENT opt_array_subscripts.{}
more_cr ::= .{}

more_comp_call ::= more_comp_call DOT IDENT.{}
more_comp_call ::= .{}

opt_comp_call ::= DOT IDENT more_comp_call. {}
opt_comp_call ::= DOT IDENT more_comp_call array_subscripts more_cr.{}
opt_comp_call ::= IDENT more_comp_call array_subscripts more_cr.{}
opt_comp_call ::= DOT IDENT more_comp_call function_call_args .{}
opt_comp_call ::= IDENT more_comp_call function_call_args FC.{}
//opt_comp_call ::= IDENT more_comp_call. {}

