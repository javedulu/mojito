%token_prefix           UMOD_LEXEME_TYPE_
%token_type             {lex::Lexeme *}
%extra_argument         {parser::Parser *parser}
%name                   umodParse

%include {
    #include <cassert>
    #include <cstdio>
    #include <vector>
    #include <string>
    #include <iostream>
    #include "lexeme.h"
    #include "parser.h"
    using namespace umod;
}
%syntax_error {
    int n = sizeof(yyTokenName)/ sizeof(*yyTokenName);
    for (int i = 0; i< n; i++)
    {
        int a = yy_find_shift_action(yypParser, static_cast<YYCODETYPE>(i));
        if (a < YY_ERROR_ACTION)
        {
            parser->errors().push_back(yyTokenName[i]);
        }
    }
    parser->error(true);
}

%left PLUS MINUS MUL DIV.

%left ASSIGN PLUSASSIGN MINUSASSIGN MULASSIGN DIVASSIGN.

%left GREATER GREATEROREQUAL LESSER LESSEROREQUAL EQUAL NOTEQUAL.

%left NOT INV INCREMENTATION DECREMENTATION.

%left LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE.

%left QUESTIONMARK DOT.

%left SEMICOLON COLON COMMA.

%left IDENT NUMBER FLOAT STRING COMMENT.

program ::= expr(A).   {
           std::cout << "Result.value=" << A << std::endl;
           std::cout << "Result.n=" << A << std::endl;
}


expr(A) ::= IDENT(B). { A = B; }